---
import { Image } from "astro:assets";
import PageLayout from "../layouts/PageLayout.astro";
import clienteleHero from "../assets/clientele_hero.png";

// Import all client logos (1-32)
import client1 from "../assets/clientele/1.png";
import client2 from "../assets/clientele/2.png";
import client3 from "../assets/clientele/3.png";
import client4 from "../assets/clientele/4.png";
import client5 from "../assets/clientele/5.png";
import client6 from "../assets/clientele/6.png";
import client7 from "../assets/clientele/7.png";
import client8 from "../assets/clientele/8.png";
import client9 from "../assets/clientele/9.png";
import client10 from "../assets/clientele/10.png";
import client11 from "../assets/clientele/11.png";
import client12 from "../assets/clientele/12.png";
import client13 from "../assets/clientele/13.png";
import client14 from "../assets/clientele/14.png";
import client15 from "../assets/clientele/15.png";
import client16 from "../assets/clientele/16.png";
import client17 from "../assets/clientele/17.png";
import client18 from "../assets/clientele/18.png";
import client19 from "../assets/clientele/19.png";
import client20 from "../assets/clientele/20.png";
import client21 from "../assets/clientele/21.png";
import client22 from "../assets/clientele/22.png";
import client23 from "../assets/clientele/23.png";
import client24 from "../assets/clientele/24.png";
import client25 from "../assets/clientele/25.png";
import client26 from "../assets/clientele/26.png";
import client27 from "../assets/clientele/27.png";
import client28 from "../assets/clientele/28.png";
import client29 from "../assets/clientele/29.png";
import client30 from "../assets/clientele/30.png";
import client31 from "../assets/clientele/31.png";
import client32 from "../assets/clientele/32.png";

const architectClients = [
  client1,
  client2,
  client3,
  client4,
  client5,
  client6,
  client7,
  client8,
  client9,
  client10,
  client11,
  client12,
  client13,
  client14,
  client15,
  client16,
];

const builderClients = [
  client17,
  client18,
  client19,
  client20,
  client21,
  client22,
  client23,
  client24,
  client25,
  client26,
  client27,
  client28,
  client29,
  client30,
  client31,
  client32,
];
---

<PageLayout title="Clientele â€¢ Kelveneers">
  <!-- Hero Section -->
  <section class="relative">
    <Image
      src={clienteleHero}
      alt="Clientele Hero Background"
      loading="eager"
      class="w-full object-cover"
    />

    <h1
      class="absolute bottom-[11%] left-[9%] text-[#E5E2D6] font-[AcidGrotesk] font-light text-lg sm:text-3xl md:text-4xl lg:text-5xl xl:text-6xl"
    >
      Our Clientele
    </h1>
  </section>

  <!-- Architects Section -->
  <section
    id="architects-section"
    class="flex flex-col items-center py-16 sm:py-20 md:py-24 lg:py-28 xl:py-32 space-y-6 sm:space-y-8 md:space-y-10"
  >
    <h2
      class="text-center font-[AcidGrotesk] font-light text-[#391B26] text-base sm:text-2xl md:text-3xl lg:text-4xl xl:text-5xl"
    >
      Architects
    </h2>
    <div
      class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-0 w-[85%] max-w-6xl"
    >
      {
        architectClients.map((client, index) => (
          <div
            class="flex items-center justify-center logo-item"
            data-index={index}
          >
            <Image
              src={client}
              alt={`Architect Client ${index + 1}`}
              loading="eager"
              class="w-full h-auto"
            />
          </div>
        ))
      }
    </div>
  </section>

  <!-- Builders Section -->
  <section
    id="builders-section"
    class="flex flex-col items-center pb-16 sm:pb-20 md:pb-24 lg:pb-28 xl:pb-32 space-y-6 sm:space-y-8 md:space-y-10"
  >
    <h2
      class="text-center font-[AcidGrotesk] font-light text-[#391B26] text-base sm:text-2xl md:text-3xl lg:text-4xl xl:text-5xl"
    >
      Builders
    </h2>
    <div
      class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-0 w-[85%] max-w-6xl"
    >
      {
        builderClients.map((client, index) => (
          <div
            class="flex items-center justify-center logo-item"
            data-index={index}
          >
            <Image
              src={client}
              alt={`Builder Client ${index + 1}`}
              loading="eager"
              class="w-full h-auto"
            />
          </div>
        ))
      }
    </div>
  </section>
</PageLayout>

<style>
  /* Fade-in animation for mobile only */
  @media (max-width: 640px) {
    .logo-item {
      opacity: 0;
      transform: translateY(20px);
      transition:
        opacity 0.6s ease-out,
        transform 0.6s ease-out;
    }

    .logo-item.fade-in {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Desktop: logos are always visible */
  @media (min-width: 641px) {
    .logo-item {
      opacity: 1;
      transform: none;
    }
  }
</style>

<script>
  // Mobile-only scroll-triggered fade-in animation for clientele logos
  (function () {
    if (typeof window === "undefined") return;

    function isMobile() {
      return window.innerWidth <= 640;
    }

    async function setupScrollFade() {
      if (!isMobile()) return;

      const INITIAL_ROWS = 5; // Auto-fade first 5 rows for architects only
      const ITEMS_PER_ROW = 2; // Mobile uses 2 columns

      for (const sectionId of ["architects-section", "builders-section"]) {
        const section = document.getElementById(sectionId);
        if (!section) return;

        const logoItems = Array.from(section.querySelectorAll(".logo-item"));
        const isArchitects = sectionId === "architects-section";

        // Group items by row
        const rowGroups = new Map<number, HTMLElement[]>();
        // Per-row cleanups for any attached 'load' listeners
        const rowLoadCleanup = new Map<number, () => void>();
        logoItems.forEach((item) => {
          const index = parseInt(item.getAttribute("data-index") || "0");
          const row = Math.floor(index / ITEMS_PER_ROW);
          if (!rowGroups.has(row)) rowGroups.set(row, []);
          rowGroups.get(row)!.push(item as HTMLElement);
        });

        const revealedRows = new Set<number>();
        // Map that tracks which individual items are currently intersecting
        const itemVisible = new Map<Element, boolean>();
        // Enforce strict first-to-last reveal. For architects, nextRowToReveal
        // starts after any auto-revealed INITIAL_ROWS.
        let nextRowToReveal = 0;

        // Auto-reveal first 5 rows for architects section with graceful stagger
        // and wait for both images in a row to be painted before revealing.
        if (isArchitects) {
          // Helper to wait for all images in a row to paint
          function waitForRowPaint(row: number, rowItems: HTMLElement[]) {
            return new Promise<void>((resolve) => {
              const imgs = rowItems
                .map(
                  (item) => item.querySelector("img") as HTMLImageElement | null
                )
                .filter(Boolean as any) as HTMLImageElement[];
              if (imgs.length === 0 || imgs.every((img) => img.complete)) {
                resolve();
                return;
              }

              const cleanups: Array<() => void> = [];
              const check = () => {
                if (imgs.every((img) => img.complete)) {
                  cleanups.forEach((c) => c());
                  resolve();
                }
              };

              imgs.forEach((img) => {
                if (img.complete) return;
                const handler = () => check();
                img.addEventListener("load", handler);
                img.addEventListener("error", handler);
                cleanups.push(() => {
                  img.removeEventListener("load", handler);
                  img.removeEventListener("error", handler);
                });
              });

              // Store cleanup so observers can clear listeners if needed
              rowLoadCleanup.set(row, () => cleanups.forEach((c) => c()));
            });
          }

          // Reveal rows sequentially after they paint, with a small stagger.
          for (let row = 0; row < INITIAL_ROWS; row++) {
            const rowItems = rowGroups.get(row);
            if (!rowItems) continue;
            // Wait for the row's images to be painted
            await new Promise((r) => setTimeout(r, 150));
            await waitForRowPaint(row, rowItems);
            // Reveal now
            rowItems.forEach((item) => {
              item.classList.add("fade-in");
              itemVisible.set(item as HTMLElement, true);
            });
            revealedRows.add(row);
          }
        }

        // Set up intersection observer for remaining rows
        // Disconnect any previous observer attached to the section so we
        // don't create duplicate observers on resize / re-init.
        if ((section as any).__clienteleObserver) {
          (section as any).__clienteleObserver.disconnect();
        }
        if ((section as any).__clienteleLoadCleanup) {
          (section as any).__clienteleLoadCleanup.forEach((fn: () => void) =>
            fn()
          );
        }

        const observer = new IntersectionObserver(
          (entries) => {
            // Update visibility map for all entries
            entries.forEach((entry) => {
              const item = entry.target as HTMLElement;
              itemVisible.set(item, entry.isIntersecting);
            });
            // Group entries by row
            const rowsToReveal = new Map<number, HTMLElement[]>();

            // Collect rows where all items are currently intersecting
            rowGroups.forEach((rowItems, row) => {
              if (revealedRows.has(row)) return;
              if (isArchitects && row < INITIAL_ROWS) return;

              // Are all items within the row visible right now?
              const allVisible = rowItems.every(
                (item) => itemVisible.get(item) === true
              );
              if (allVisible) {
                if (!rowsToReveal.has(row)) rowsToReveal.set(row, []);
                rowsToReveal.get(row)!.push(...rowItems);
              }
            });

            // Reveal complete rows only (both items visible)
            // Only reveal rows in strict sequence: nextRowToReveal, then
            // advance if subsequent rows are already available.
            const sortedRows = Array.from(rowsToReveal.keys()).sort(
              (a, b) => a - b
            );
            sortedRows.forEach((row) => {
              const items2 = rowsToReveal.get(row) || [];
              const rowItems = rowGroups.get(row) || [];
              const allItemsInView = rowItems.every(
                (item) => itemVisible.get(item) === true
              );

              if (
                allItemsInView &&
                row === nextRowToReveal &&
                !revealedRows.has(row)
              ) {
                // Stop any pending load listeners for this row (if present)
                if (rowLoadCleanup.has(row)) {
                  rowLoadCleanup.get(row)!();
                  rowLoadCleanup.delete(row);
                }

                const allImgs = rowItems.map((item) =>
                  item.querySelector("img")
                );
                const allPainted = allImgs.every(
                  (img) => (img as HTMLImageElement)?.complete === true
                );

                const revealNow = () => {
                  rowItems.forEach((item) => {
                    item.classList.add("fade-in");
                    observer.unobserve(item);
                    // mark as revealed in itemVisible
                    itemVisible.set(item, true);
                  });
                  revealedRows.add(row);
                  nextRowToReveal++;
                };

                if (allPainted) {
                  revealNow();
                } else {
                  // Wait for any not-yet-loaded images in this row to finish,
                  // then reveal if still visible and un-revealed.
                  const cleanups: Array<() => void> = [];
                  const checkPaintAndReveal = () => {
                    const nowPainted = rowItems.every((item) => {
                      const img = item.querySelector(
                        "img"
                      ) as HTMLImageElement | null;
                      return img ? img.complete : true;
                    });
                    const stillVisible = rowItems.every(
                      (item) => itemVisible.get(item) === true
                    );
                    if (nowPainted && stillVisible && !revealedRows.has(row)) {
                      revealNow();
                      cleanups.forEach((c) => c());
                      rowLoadCleanup.delete(row);
                    }
                  };

                  rowItems.forEach((item) => {
                    const img = item.querySelector(
                      "img"
                    ) as HTMLImageElement | null;
                    if (!img) return;
                    if (img.complete) return;
                    const h = () => checkPaintAndReveal();
                    img.addEventListener("load", h);
                    cleanups.push(() => img.removeEventListener("load", h));
                  });

                  rowLoadCleanup.set(row, () => cleanups.forEach((c) => c()));
                }
                // (reveal logic above already sets revealedRows and nextRowToReveal)
                // Continue revealing any sequentially next rows that are
                // already visible.
                while (true) {
                  const nextRowItems = rowGroups.get(nextRowToReveal) || [];
                  if (!nextRowItems.length) break;
                  const nextAllVisible = nextRowItems.every(
                    (item) => itemVisible.get(item) === true
                  );
                  if (!nextAllVisible) break;
                  nextRowItems.forEach((item) => {
                    item.classList.add("fade-in");
                    observer.unobserve(item);
                    itemVisible.set(item, true);
                  });
                  revealedRows.add(nextRowToReveal);
                  nextRowToReveal++;
                }
              }
            });
          },
          {
            threshold: 0.1,
            rootMargin: "0px 0px -50px 0px",
          }
        );

        // If architects, skip initial row range since those were auto-revealed
        if (isArchitects) {
          nextRowToReveal = INITIAL_ROWS;
        }

        // Observe items that need scroll-triggering
        logoItems.forEach((item) => {
          const index = parseInt(item.getAttribute("data-index") || "0");
          const row = Math.floor(index / ITEMS_PER_ROW);
          if (!isArchitects || row >= INITIAL_ROWS) {
            itemVisible.set(item, false);
            observer.observe(item);
          } else {
            // mark them visible and considered revealed already
            itemVisible.set(item, true);
          }
        });
        // Save a reference so we can disconnect when reinitializing
        (section as any).__clienteleObserver = observer;
        (section as any).__clienteleLoadCleanup = rowLoadCleanup;
      }
    }

    // Initialize on load
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", setupScrollFade);
    } else {
      setupScrollFade();
    }

    // Re-initialize on viewport resize
    let wasMobile = isMobile();
    window.addEventListener("resize", () => {
      const nowMobile = isMobile();
      if (nowMobile !== wasMobile) {
        wasMobile = nowMobile;
        if (nowMobile) setupScrollFade();
      }
    });
  })();
</script>
