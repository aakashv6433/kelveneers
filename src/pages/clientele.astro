---
import { Image } from "astro:assets";
import PageLayout from "../layouts/PageLayout.astro";
import clienteleHero from "../assets/clientele_hero.png";

// Import all client logos (1-32)
import client1 from "../assets/clientele/1.png";
import client2 from "../assets/clientele/2.png";
import client3 from "../assets/clientele/3.png";
import client4 from "../assets/clientele/4.png";
import client5 from "../assets/clientele/5.png";
import client6 from "../assets/clientele/6.png";
import client7 from "../assets/clientele/7.png";
import client8 from "../assets/clientele/8.png";
import client9 from "../assets/clientele/9.png";
import client10 from "../assets/clientele/10.png";
import client11 from "../assets/clientele/11.png";
import client12 from "../assets/clientele/12.png";
import client13 from "../assets/clientele/13.png";
import client14 from "../assets/clientele/14.png";
import client15 from "../assets/clientele/15.png";
import client16 from "../assets/clientele/16.png";
import client17 from "../assets/clientele/17.png";
import client18 from "../assets/clientele/18.png";
import client19 from "../assets/clientele/19.png";
import client20 from "../assets/clientele/20.png";
import client21 from "../assets/clientele/21.png";
import client22 from "../assets/clientele/22.png";
import client23 from "../assets/clientele/23.png";
import client24 from "../assets/clientele/24.png";
import client25 from "../assets/clientele/25.png";
import client26 from "../assets/clientele/26.png";
import client27 from "../assets/clientele/27.png";
import client28 from "../assets/clientele/28.png";
import client29 from "../assets/clientele/29.png";
import client30 from "../assets/clientele/30.png";
import client31 from "../assets/clientele/31.png";
import client32 from "../assets/clientele/32.png";

const architectClients = [
  client1,
  client2,
  client3,
  client4,
  client5,
  client6,
  client7,
  client8,
  client9,
  client10,
  client11,
  client12,
  client13,
  client14,
  client15,
  client16,
];

const builderClients = [
  client17,
  client18,
  client19,
  client20,
  client21,
  client22,
  client23,
  client24,
  client25,
  client26,
  client27,
  client28,
  client29,
  client30,
  client31,
  client32,
];
// How many initial images to prioritize (covers a couple of rows on larger breakpoints).
const PRIORITY_COUNT = 12;
---

<PageLayout title="Clientele â€¢ Kelveneers">
  <!-- Hero Section -->
  <section class="relative">
    <Image
      src={clienteleHero}
      alt="Clientele Hero Background"
      loading="eager"
      priority={true}
      class="w-full object-cover"
    />

    <h1
      class="absolute bottom-[11%] left-[9%] text-[#E5E2D6] font-[AcidGrotesk] font-light text-lg sm:text-3xl md:text-4xl lg:text-5xl xl:text-6xl"
    >
      Our Clientele
    </h1>
  </section>

  <!-- Architects Section -->
  <section
    id="architects-section"
    class="flex flex-col items-center py-16 sm:py-20 md:py-24 lg:py-28 xl:py-32 space-y-6 sm:space-y-8 md:space-y-10"
  >
    <h2
      class="text-center font-[AcidGrotesk] font-light text-[#391B26] text-base sm:text-2xl md:text-3xl lg:text-4xl xl:text-5xl"
    >
      Architects
    </h2>
    <div
      class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-0 w-[85%] max-w-6xl"
    >
      {
        architectClients.map((client, index) => (
          <div
            class="flex items-center justify-center logo-item"
            data-index={index}
          >
            <Image
              src={client}
              alt={`Architect Client ${index + 1}`}
              loading="eager"
              priority={index < PRIORITY_COUNT}
              class="w-full h-auto"
            />
          </div>
        ))
      }
    </div>
  </section>

  <!-- Builders Section -->
  <section
    id="builders-section"
    class="flex flex-col items-center pb-16 sm:pb-20 md:pb-24 lg:pb-28 xl:pb-32 space-y-6 sm:space-y-8 md:space-y-10"
  >
    <h2
      class="text-center font-[AcidGrotesk] font-light text-[#391B26] text-base sm:text-2xl md:text-3xl lg:text-4xl xl:text-5xl"
    >
      Builders
    </h2>
    <div
      class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-0 w-[85%] max-w-6xl"
    >
      {
        builderClients.map((client, index) => (
          <div
            class="flex items-center justify-center logo-item"
            data-index={index}
          >
            <Image
              src={client}
              alt={`Builder Client ${index + 1}`}
              loading="eager"
              class="w-full h-auto"
            />
          </div>
        ))
      }
    </div>
  </section>
</PageLayout>

<style>
  .logo-item {
    opacity: 0;
    transform: translateY(13px);
    transition:
      opacity 0.33s ease-out,
      transform 0.33s ease-out;
  }

  .logo-item.fade-in {
    opacity: 1;
    transform: translateY(0);
  }

  /* Slower, more graceful reveal on small screens */
  @media (max-width: 640px) {
    .logo-item {
      transition:
        opacity 0.48s ease-out,
        transform 0.48s ease-out;
    }
  }
</style>
<script>
  // Reset scroll position to top on page load/refresh
  if (history.scrollRestoration) {
    history.scrollRestoration = "manual";
  }
  window.scrollTo(0, 0);

  document.addEventListener("DOMContentLoaded", () => {
    // NOTE: priority for architects is fixed to 12 here for client-side logic.
    const logoItems = Array.from(document.querySelectorAll(".logo-item"));

    // Determine reveal cadence by breakpoint: make mobile slower.
    // Desktop (>=768): snappy 50ms between items. Tablet (640-767): 60ms.
    // Mobile (<640): slower 115ms so the sequential animation doesn't feel rushed.
    const revealIntervalMs =
      window.innerWidth >= 768 ? 50 : window.innerWidth >= 640 ? 60 : 115;

    // We'll prioritize only the first N architect logos. On mobile we want
    // fewer prioritized images (8) to reduce initial bandwidth and improve
    // perceived load speed.
    const architectItems = Array.from(
      document.querySelectorAll("#architects-section .logo-item")
    );
    const mobilePriority = window.innerWidth < 640 ? 8 : 12;
    const prioritizedArchitectCount = Math.min(
      architectItems.length,
      mobilePriority
    );

    // If on mobile, downgrade loading for architect images beyond the
    // mobile priority so they don't behave as prioritized (lazy-load them
    // and remove any preload links if present).
    if (window.innerWidth < 640) {
      architectItems.forEach((item, idx) => {
        const img = item.querySelector("img");
        if (img && idx >= mobilePriority) {
          try {
            img.loading = "lazy";
            const href = img.currentSrc || img.getAttribute("src");
            if (href) {
              const preloadLink = document.querySelector(
                `link[rel="preload"][as="image"][href="${href}"]`
              );
              if (preloadLink) preloadLink.remove();
            }
          } catch (e) {
            // non-fatal
          }
        }
      });
    }

    // Accessibility: if user prefers reduced motion, reveal all immediately
    const prefersReduced =
      window.matchMedia &&
      window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    if (prefersReduced) {
      logoItems.forEach((item) => item.classList.add("fade-in"));
      return;
    }
    // Immediately reveal the first PRIORITY_COUNT architect logos so the
    // top of the page looks populated quickly. Do NOT apply this to builders.
    architectItems.slice(0, prioritizedArchitectCount).forEach((item) => {
      item.classList.add("fade-in");
    });

    // Start the sequential reveal after the items we've already made visible.
    // Compute how many items in the global list are already visible and start
    // after that index so builders (which come after) are not pre-revealed.
    const alreadyVisible = logoItems.filter((it) =>
      it.classList.contains("fade-in")
    ).length;
    let currentIndex = Math.max(alreadyVisible, 0);
    const total = logoItems.length;

    // Reveal the next logo in strict document order. Instead of using a
    // fixed interval we chain off each element's transitionend so the next
    // reveal only starts after the current reveal completes. This enforces
    // strict sequencing even if rendering/painting timing varies. The
    // animation is intentionally run on every refresh.
    function revealNext() {
      if (currentIndex >= total) return;

      const item = logoItems[currentIndex];
      if (!item) {
        currentIndex += 1;
        // Immediately proceed if an item is missing
        revealNext();
        return;
      }

      // Start the transition for this item
      item.classList.add("fade-in");
      currentIndex += 1;

      let settled = false;
      const onSettled = () => {
        if (settled) return;
        settled = true;
        setTimeout(revealNext, revealIntervalMs);
      };

      // Listen for transitionend on either opacity or transform. Use once
      // so the handler removes itself.
      item.addEventListener(
        "transitionend",
        (ev) => {
          // Cast to TransitionEvent so TypeScript recognizes propertyName
          const prop = (ev as TransitionEvent).propertyName;
          if (prop === "opacity" || prop === "transform") {
            onSettled();
          }
        },
        { once: true }
      );

      // Fallback: if transitionend doesn't fire, proceed after a shorter timeout.
      setTimeout(onSettled, revealIntervalMs + 120);
    }

    // Start the chain immediately
    revealNext();
  });
</script>
